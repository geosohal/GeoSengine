#version 430
// ambient occlusion using Alchemy method and deferred shading

#define pi   3.1415926535897932384626433832795
#define pi2  6.2831853071795864769252867665590
const float MIN_DEPTH = .3f;
const float MAX_DEPTH = 200.0f;

// ambient occlusion constants
uniform float ROI = 10.5f;	// range of influence squared for heaviside step function
uniform float AOC = .15;	// .1 * ROI, const for falloff function
uniform float AOCSQ = .0225f;

// depth modifier, additive offset to handle cases where distance introduces error with our
// normal and omega in these cases delta scales shadow when we are in corner or crack
uniform float DELTA = 0.0025f;
uniform int numSamples = 20;  // number of nearby pixels to sample
uniform float scale = 8.f;  // intensity of shadow
uniform float contrast = 1.55f; // power modifier for contrast control of shadow

uniform sampler2D positionMap;// from gbuffer
uniform sampler2D normalMap;	// from gbuffer
uniform sampler2D depthMap;	//from gbuffer
//uniform sampler2D aoMap;

uniform int screenWidth;
uniform int screenHeight;

layout (location = 0) out float aoOut;

in vec2 TexCoord0;
in vec3 Normal0;
in vec3 WorldPos0;

vec2 CalcTexCoord()
{
   return gl_FragCoord.xy / vec2(screenWidth,screenHeight);
}
vec2 Hammersley(uint i, uint N)
{
  return vec2( float(i) / float(N), float(bitfieldReverse(i)) * 2.3283064365386963e-10 );
}

float randAngle()
{
  uint x = uint(gl_FragCoord.x);
  uint y = uint(gl_FragCoord.y);
  return (30u * x ^ y + 10u * x * y);
}

// pixelDepth is in camera space depth
float CalcAOFactor(vec3 N, vec3 P, float pixelDepth)
{
        vec2 coords = CalcTexCoord();
        float occlSum = 0;
        for (int i = 0; i < numSamples; i++)
        {
            // generate random point to sample for occlusion
            float alpha = (i + 0.5f) / numSamples;
            float h = alpha * ROI / pixelDepth;
            uint x = uint(gl_FragCoord.x);
            uint y = uint(gl_FragCoord.y);

            float phi = (30u* x ^ y + 10u * x * y);// rand angle
            float theta = pi2 * alpha * (7*numSamples/9) + phi;
            vec2 pointiCoord = coords + h*vec2(cos(theta), sin(theta));
            vec3 pointi = texture(positionMap, pointiCoord).xyz;

            // calculate amount of occlusion generated by this sample
            vec3 omegai = pointi - P;
            float omegaiLenSq = dot(omegai, omegai);
            float H = clamp((ROI - omegaiLenSq)*100000, 0, 1);// dont count points outside of ROI
            float NoW = dot(N, omegai);
            occlSum += max(0, NoW-DELTA*pixelDepth) * H / max(.0001, omegaiLenSq);
        }
        //occlSum *= (pi2*AOC*(1000*clamp(pixelDepth-.7,0,1)))/numSamples;
        occlSum *= (pi2*AOC*pixelDepth)/numSamples;
        return clamp( pow(1-scale*occlSum, contrast), 0, 1 );
}

void main()
{
        vec2 TexCoord = CalcTexCoord();
        float depth = texture(depthMap, TexCoord).x ;
        vec3 N = texture(normalMap, TexCoord).xyz;
        vec3 pos = texture(positionMap, TexCoord).xyz;
        float AOfactor = CalcAOFactor(N, pos, depth);
        aoOut = AOfactor;
}
